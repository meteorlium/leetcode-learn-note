# Python 位运算详解

## 核心要点

**面试重点：**
- 位运算基本操作（与、或、异或、非、移位）
- 负数的补码表示和位运算特殊行为
- 常用位运算技巧（判断奇偶、交换变量、快速乘除）
- 位掩码和状态压缩DP的应用
- 位运算优化算法的时间复杂度

## 基本位运算操作

### 1. 基础运算符

```python
from typing import List

# 按位与 &：两位都为1时结果为1
def bitwise_and_demo() -> None:
    a, b = 12, 10  # 1100 & 1010 = 1000
    result = a & b  # 8
    print(f"{a} & {b} = {result}")

# 按位或 |：有一位为1时结果为1  
def bitwise_or_demo() -> None:
    a, b = 12, 10  # 1100 | 1010 = 1110
    result = a | b  # 14
    print(f"{a} | {b} = {result}")

# 按位异或 ^：两位不同时结果为1
def bitwise_xor_demo() -> None:
    a, b = 12, 10  # 1100 ^ 1010 = 0110
    result = a ^ b  # 6
    print(f"{a} ^ {b} = {result}")

# 按位取反 ~：0变1，1变0
def bitwise_not_demo() -> None:
    a = 12  # ~1100 = ...11110011 (补码表示)
    result = ~a  # -13
    print(f"~{a} = {result}")

# 左移 <<：向左移动n位，相当于乘以2^n
def left_shift_demo() -> None:
    a = 12  # 1100 << 2 = 110000
    result = a << 2  # 48
    print(f"{a} << 2 = {result}")

# 右移 >>：向右移动n位，相当于整除2^n
def right_shift_demo() -> None:
    a = 12  # 1100 >> 2 = 11
    result = a >> 2  # 3
    print(f"{a} >> 2 = {result}")
```

### 2. 常用位运算性质

```python
def bit_properties() -> None:
    """位运算重要性质 - 面试高频考点"""
    
    # 1. 任何数与0异或等于自身
    assert 5 ^ 0 == 5
    
    # 2. 任何数与自身异或等于0
    assert 5 ^ 5 == 0
    
    # 3. 异或满足交换律和结合律
    assert (5 ^ 3) ^ 7 == 5 ^ (3 ^ 7)
    
    # 4. 与运算性质
    assert 5 & 0 == 0  # 任何数与0的与运算为0
    assert 5 & 5 == 5  # 任何数与自身的与运算为自身
    
    # 5. 或运算性质
    assert 5 | 0 == 5  # 任何数与0的或运算为自身
    assert 5 | 5 == 5  # 任何数与自身的或运算为自身
```

## 负数位运算详解

### 1. 为什么要用补码表示负数？

```python
def why_complement_representation() -> None:
    """为什么要用补码 - 深层原理解析"""
    
    # 问题1：其他表示方法的局限性
    
    # 方法1：符号位表示法（最直观但有问题）
    # 8位示例：+5 = 00000101, -5 = 10000101
    # 问题：+0 = 00000000, -0 = 10000000 (两个0!)
    # 问题：加法运算复杂，需要特殊处理符号位
    
    # 方法2：反码表示法（补码的前身）  
    # +5 = 00000101, -5 = 11111010 (正数按位取反)
    # 问题：仍然有+0和-0的问题
    # 问题：加法运算需要循环进位
    
    # 方法3：补码表示法（现代计算机标准）
    # +5 = 00000101, -5 = 11111011 (反码+1)
    # 优点1：只有一个0
    # 优点2：加法运算统一，不需要特殊处理
    
    print("补码的核心优势：")
    print("1. 统一加法运算：正数+负数 = 正常二进制加法")
    print("2. 唯一的零表示：避免+0和-0的歧义")
    print("3. 硬件实现简单：不需要专门的减法电路")
```

### 2. 补码表示原理详解

```python
def complement_representation_details() -> None:
    """补码表示的核心原理 - 面试必知"""
    
    # 核心理解：补码不是简单的"符号位"概念！
    # 而是基于模运算的数学原理
    
    # 以8位为例，范围是 -128 到 +127
    # 关键：最高位权重是 -128 而不是 +128
    
    def explain_bit_weights() -> None:
        """解释位权重概念"""
        # 8位无符号数：权重为 128 64 32 16 8 4 2 1
        # 8位补码：权重为 -128 64 32 16 8 4 2 1  (注意最高位!)
        
        # 例子：10000101 在补码中的值
        value = -128*1 + 64*0 + 32*0 + 16*0 + 8*0 + 4*1 + 2*0 + 1*1
        print(f"10000101 (补码) = {value}")  # -123
        
        # 这就是为什么最高位为1通常表示负数
        # 但本质是权重为负，不是"符号位"！
    
    explain_bit_weights()
    
    # 补码的数学本质：模运算
    # 在n位系统中，-x 的补码 = 2^n - x
    def complement_formula() -> None:
        """补码的数学公式"""
        # 8位系统中，-5 的补码计算：
        # 2^8 - 5 = 256 - 5 = 251 = 11111011
        n_bits = 8
        x = 5
        complement = (1 << n_bits) - x
        print(f"{n_bits}位系统中，-{x}的补码 = {complement} = {bin(complement)}")
    
    complement_formula()
```

### 3. 不同位数系统的补码

```python
def different_bit_systems() -> None:
    """不同位数下的补码表示 - 重要概念"""
    
    # 关键理解：必须事先约定位数！
    # 同一个数在不同位数下的补码不同
    
    def show_different_widths(num: int) -> None:
        """显示同一个数在不同位宽下的表示"""
        for bits in [4, 8, 16, 32]:
            if num >= 0:
                binary = format(num, f'0{bits}b')
            else:
                # 负数：计算对应位数的补码
                mask = (1 << bits) - 1  # 生成掩码
                binary = format(num & mask, f'0{bits}b')
            
            max_pos = (1 << (bits-1)) - 1
            min_neg = -(1 << (bits-1))
            print(f"{bits}位: {binary} (范围: {min_neg} 到 {max_pos})")
    
    print("数字 -5 在不同位数下的表示:")
    show_different_widths(-5)
    
    print("\n数字 200 在不同位数下的表示:")
    show_different_widths(200)  # 注意8位时会溢出！
    
    # 位数确定了表示范围
    def show_ranges() -> None:
        """显示不同位数的表示范围"""
        print("\n各位数补码表示范围:")
        for bits in [4, 8, 16, 32, 64]:
            max_pos = (1 << (bits-1)) - 1
            min_neg = -(1 << (bits-1))
            print(f"{bits}位: {min_neg} 到 {max_pos}")
    
    show_ranges()
```

### 4. 补码运算的数学美感

```python
def complement_arithmetic_beauty() -> None:
    """补码运算的优雅之处 - 面试加分点"""
    
    # 美感1：加法的统一性
    def unified_addition() -> None:
        """补码加法的统一性"""
        # 无论正负，都是普通二进制加法，忽略溢出位
        
        # 5 + (-3) = 2 的补码运算（8位）
        a = 5   # 00000101
        b = -3  # 11111101 (补码)
        
        # 直接二进制相加：
        # 00000101
        # 11111101
        # --------
        #100000010 (忽略最高位溢出)
        # 00000010 = 2 ✓
        
        result = (a + b) & 0xFF  # 模拟8位加法
        print(f"5 + (-3) = {result} (补码加法)")
    
    unified_addition()
    
    # 美感2：减法转加法
    def subtraction_as_addition() -> None:
        """减法等价于加负数"""
        # a - b = a + (-b)
        # 而 -b 就是 b 的补码！
        
        # 7 - 3 = 7 + (-3)
        a = 7   # 00000111
        b = 3   # 00000011
        neg_b = ((~b) + 1) & 0xFF  # -3 的补码
        
        result = (a + neg_b) & 0xFF
        print(f"7 - 3 = 7 + (-3) = {result} (减法转加法)")
    
    subtraction_as_addition()
    
    # 美感3：溢出检测简单
    def overflow_detection() -> None:
        """溢出检测规律"""
        # 两个正数相加得负数 -> 正溢出
        # 两个负数相加得正数 -> 负溢出
        # 一正一负相加永远不溢出
        
        def check_overflow(a: int, b: int, bits: int = 8) -> bool:
            """检测加法溢出"""
            max_val = (1 << (bits-1)) - 1
            min_val = -(1 << (bits-1))
            
            # 符号相同才可能溢出
            if (a > 0 and b > 0 and a + b > max_val) or \
               (a < 0 and b < 0 and a + b < min_val):
                return True
            return False
        
        test_cases = [(100, 50), (-100, -50), (100, -50)]
        for a, b in test_cases:
            overflow = check_overflow(a, b)
            print(f"{a} + {b} = {a+b}, 溢出: {overflow}")
    
    overflow_detection()
```

### 5. 为什么最高位"看起来"是符号位？

```python
def why_msb_looks_like_sign() -> None:
    """为什么最高位看起来像符号位 - 本质解释"""
    
    # 关键理解：最高位权重为负值
    # 这导致它的值决定了整体的正负性
    
    def demonstrate_msb_weight() -> None:
        """演示最高位的负权重效应"""
        print("8位补码中各位的权重:")
        weights = [-128, 64, 32, 16, 8, 4, 2, 1]
        for i, w in enumerate(weights):
            print(f"第{7-i}位: 权重 {w}")
        
        print("\n当最高位为1时:")
        # 即使其他位都是0，值也是-128
        print("10000000 = -128*1 = -128")
        
        print("\n当最高位为0时:")  
        # 最大值是所有其他位为1
        print("01111111 = 64+32+16+8+4+2+1 = 127")
        
        print("\n结论：最高位为1 -> 整体必为负数")
        print("       最高位为0 -> 整体必为正数")
        print("这就是为什么最高位'看起来'像符号位！")
    
    demonstrate_msb_weight()
```

### 6. 负数位运算行为

```python
def negative_bit_operations() -> None:
    """负数位运算的特殊行为 - 面试陷阱题"""
    
    # 1. 按位取反的结果
    print(f"~5 = {~5}")    # -6
    print(f"~(-5) = {~(-5)}")  # 4
    # 规律：~n = -(n+1)
    
    # 2. 右移操作的符号扩展
    positive_shift = 8 >> 2   # 2
    negative_shift = -8 >> 2  # -2 (算术右移，保持符号)
    print(f"8 >> 2 = {positive_shift}")
    print(f"-8 >> 2 = {negative_shift}")
    
    # 3. 左移操作
    print(f"-8 << 2 = {-8 << 2}")  # -32
    
    # 4. 与运算的符号处理
    result1 = 5 & -3    # 正数与负数
    result2 = -5 & -3   # 负数与负数
    print(f"5 & -3 = {result1}")
    print(f"-5 & -3 = {result2}")
    
    # 5. 异或运算的特殊性质
    # 负数异或正数
    print(f"5 ^ -3 = {5 ^ -3}")
    print(f"-5 ^ 3 = {-5 ^ 3}")
```

### 7. 负数位运算的实际应用

```python
def negative_bit_applications() -> None:
    """负数位运算的实际应用场景"""
    
    # 1. 获取最低位的1（包括负数）
    def get_lowest_set_bit(n: int) -> int:
        """获取最低位的1，对负数也适用"""
        return n & (-n)
    
    # 测试正数和负数
    print(f"最低位的1:")
    print(f"12的最低位1: {get_lowest_set_bit(12)}")    # 4
    print(f"-12的最低位1: {get_lowest_set_bit(-12)}")  # 4
    
    # 2. 符号判断
    def get_sign(n: int) -> int:
        """获取数字的符号：1为正，-1为负，0为零"""
        if n == 0:
            return 0
        # 利用右移31位获取符号位（假设32位整数）
        return 1 if n > 0 else -1
    
    # 3. 无分支绝对值计算
    def abs_without_branch(n: int) -> int:
        """无分支计算绝对值（32位整数）"""
        mask = n >> 31  # 获取符号位掩码
        return (n ^ mask) - mask
    
    # 4. 两数符号是否相同
    def same_sign(a: int, b: int) -> bool:
        """判断两数符号是否相同"""
        return (a ^ b) >= 0
    
    print(f"\n符号判断测试:")
    print(f"5和3同号: {same_sign(5, 3)}")    # True
    print(f"5和-3同号: {same_sign(5, -3)}")  # False
    print(f"-5和-3同号: {same_sign(-5, -3)}")  # True
```

### 8. 负数位运算常见陷阱

```python
def negative_bit_traps() -> None:
    """负数位运算常见陷阱 - 面试易错点"""
    
    # 陷阱1：右移负数的行为
    # C++/Java：算术右移（保持符号）
    # Python：同样是算术右移
    print(f"陷阱1 - 右移负数:")
    print(f"-1 >> 1 = {-1 >> 1}")  # -1 (不是期望的大正数)
    
    # 陷阱2：位运算优先级
    # 位运算优先级低于比较运算符
    n = 5
    # 错误写法：n & 1 == 1 会被解析为 n & (1 == 1)
    # 正确写法：(n & 1) == 1
    
    # 陷阱3：负数的模运算
    print(f"\n陷阱3 - 负数模运算:")
    print(f"-5 % 4 = {-5 % 4}")  # Python: 3, C++/Java: -1
    print(f"-5 & 3 = {-5 & 3}")  # 3 (位运算结果一致)
    
    # 陷阱4：溢出边界情况
    # 最小负数取反后仍是负数（在固定位数下）
    INT_MIN = -2**31  # 32位有符号整数最小值
    print(f"\n陷阱4 - 溢出边界:")
    print(f"INT_MIN = {INT_MIN}")
    print(f"~INT_MIN = {~INT_MIN}")  # 2147483647
```

### 9. LeetCode中的负数位运算题目

```python
def negative_bit_leetcode_examples() -> None:
    """LeetCode中涉及负数位运算的题目"""
    
    # Example 1: LeetCode 371 - 两整数之和（不用+号）
    def get_sum(a: int, b: int) -> int:
        """使用位运算实现加法，处理负数"""
        # Python需要处理负数的特殊情况
        mask = 0xFFFFFFFF  # 32位掩码
        
        while b:
            carry = (a & b) << 1
            a = (a ^ b) & mask
            b = carry & mask
        
        # 处理负数结果
        return a if a < 0x80000000 else ~(a ^ mask)
    
    # Example 2: 位1的个数（包括负数）
    def hamming_weight_with_negative(n: int) -> int:
        """计算包括负数在内的汉明权重"""
        if n >= 0:
            count = 0
            while n:
                count += 1
                n &= n - 1
            return count
        else:
            # 负数：先转换为32位无符号表示
            n = n & 0xFFFFFFFF
            count = 0
            while n:
                count += 1
                n &= n - 1
            return count
    
    print(f"负数位运算应用示例:")
    print(f"get_sum(5, -3) = {get_sum(5, -3)}")
    print(f"hamming_weight(-1) = {hamming_weight_with_negative(-1)}")
```

### 10. 负数位运算总结表

| 操作 | 正数示例 | 负数示例 | 注意事项 |
|------|----------|----------|----------|
| `~n` | `~5 = -6` | `~(-5) = 4` | 规律：`~n = -(n+1)` |
| `n >> k` | `8 >> 2 = 2` | `-8 >> 2 = -2` | 算术右移，保持符号 |
| `n << k` | `5 << 1 = 10` | `-5 << 1 = -10` | 符号位一起移动 |
| `n & (-n)` | `12 & (-12) = 4` | `-12 & 12 = 4` | 获取最低位的1 |
| `a ^ b >= 0` | `5 ^ 3 >= 0` ✓ | `5 ^ (-3) >= 0` ✗ | 判断同号 |

## 实用位运算技巧

### 1. 基础判断操作

```python
def basic_bit_tricks() -> None:
    """基础位运算技巧 - 面试常考"""
    
    # 判断奇偶性
    def is_odd(n: int) -> bool:
        return (n & 1) == 1
    
    # 判断是否为2的幂
    def is_power_of_two(n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0
    
    # 获取最低位的1
    def get_lowest_bit(n: int) -> int:
        return n & (-n)
    
    # 清除最低位的1
    def clear_lowest_bit(n: int) -> int:
        return n & (n - 1)
    
    # 计算二进制中1的个数（汉明权重）
    def count_ones(n: int) -> int:
        count = 0
        while n:
            count += 1
            n &= n - 1  # 清除最低位的1
        return count
```

### 2. 位掩码操作

```python
def bit_mask_operations() -> None:
    """位掩码操作 - 状态压缩DP核心"""
    
    # 设置第i位为1
    def set_bit(num: int, i: int) -> int:
        return num | (1 << i)
    
    # 清除第i位（设为0）
    def clear_bit(num: int, i: int) -> int:
        return num & ~(1 << i)
    
    # 切换第i位
    def toggle_bit(num: int, i: int) -> int:
        return num ^ (1 << i)
    
    # 检查第i位是否为1
    def check_bit(num: int, i: int) -> bool:
        return (num & (1 << i)) != 0
    
    # 获取从第i位到第j位的数值
    def get_bits(num: int, i: int, j: int) -> int:
        mask = (1 << (j - i + 1)) - 1
        return (num >> i) & mask
```

## LeetCode 常见应用场景

### 1. 数组去重与查找

```python
def find_single_number(nums: List[int]) -> int:
    """
    LeetCode 136: 只出现一次的数字
    利用异或性质：相同数字异或为0，任何数与0异或为自身
    """
    result = 0
    for num in nums:
        result ^= num
    return result

def find_two_single_numbers(nums: List[int]) -> List[int]:
    """
    LeetCode 260: 只出现一次的数字 III
    两个不同的数字只出现一次，其余都出现两次
    """
    # 第一步：得到两个单独数字的异或结果
    xor = 0
    for num in nums:
        xor ^= num
    
    # 第二步：找到任意一个为1的位
    diff = xor & (-xor)
    
    # 第三步：根据该位分组
    a, b = 0, 0
    for num in nums:
        if num & diff:
            a ^= num
        else:
            b ^= num
    
    return [a, b]
```

### 2. 子集生成

```python
def generate_subsets(nums: List[int]) -> List[List[int]]:
    """
    LeetCode 78: 子集
    使用位运算生成所有子集
    """
    n = len(nums)
    result = []
    
    # 遍历所有可能的位掩码
    for mask in range(1 << n):
        subset = []
        for i in range(n):
            # 如果第i位为1，则包含nums[i]
            if mask & (1 << i):
                subset.append(nums[i])
        result.append(subset)
    
    return result
```

### 3. 状态压缩动态规划

```python
def shortest_path_visiting_all_nodes(graph: List[List[int]]) -> int:
    """
    LeetCode 847: 访问所有节点的最短路径
    状态压缩DP经典题目
    """
    from collections import deque
    
    n = len(graph)
    # 状态：(节点, 访问过的节点集合)
    queue = deque()
    visited = set()
    
    # 初始化：从每个节点开始
    for i in range(n):
        state = (i, 1 << i)
        queue.append((state, 0))
        visited.add(state)
    
    target = (1 << n) - 1  # 所有节点都被访问
    
    while queue:
        (node, mask), steps = queue.popleft()
        
        if mask == target:
            return steps
        
        for next_node in graph[node]:
            next_mask = mask | (1 << next_node)
            next_state = (next_node, next_mask)
            
            if next_state not in visited:
                visited.add(next_state)
                queue.append((next_state, steps + 1))
    
    return -1
```

## 面试重点技巧

### 1. 快速计算技巧

```python
def quick_calculations() -> None:
    """快速计算技巧 - 面试加分项"""
    
    # 快速乘以2的幂
    def multiply_by_power_of_2(n: int, k: int) -> int:
        return n << k  # n * 2^k
    
    # 快速除以2的幂
    def divide_by_power_of_2(n: int, k: int) -> int:
        return n >> k  # n // 2^k
    
    # 交换两个变量（不使用临时变量）
    def swap_without_temp(a: int, b: int) -> tuple[int, int]:
        a ^= b
        b ^= a
        a ^= b
        return a, b
    
    # 求绝对值（适用于32位整数）
    def abs_value(n: int) -> int:
        mask = n >> 31  # 获取符号位
        return (n + mask) ^ mask
```

### 2. 常见面试题模式

```python
def common_interview_patterns() -> None:
    """常见面试题模式总结"""
    
    # 模式1：找出现次数不同的数字
    # 技巧：利用异或的性质
    
    # 模式2：位掩码表示状态
    # 技巧：用整数的每一位表示某种状态
    
    # 模式3：子集生成
    # 技巧：遍历所有可能的位掩码
    
    # 模式4：位运算优化
    # 技巧：用位运算替代取模、乘除等操作
    
    pass
```

## 性能对比

| 操作 | 普通实现 | 位运算实现 | 性能提升 |
|------|----------|------------|----------|
| 判断奇偶 | `n % 2` | `n & 1` | ~2倍 |
| 乘以2 | `n * 2` | `n << 1` | ~1.5倍 |
| 除以2 | `n // 2` | `n >> 1` | ~1.5倍 |
| 计算2^k | `2 ** k` | `1 << k` | ~3倍 |

## 注意事项

1. **符号位处理**：Python中的整数是任意精度的，右移操作会保持符号
2. **负数补码**：负数使用补码表示，`~n = -(n+1)`，右移负数是算术右移
3. **位运算优先级**：位运算符优先级低于比较运算符，需要加括号
4. **溢出问题**：在其他语言中需要注意整数溢出，Python自动处理
5. **跨语言差异**：负数模运算在Python和C++/Java中结果不同
6. **可读性平衡**：位运算虽然高效，但要在性能和可读性之间找平衡
7. **调试困难**：位运算代码调试相对困难，建议添加详细注释

## 总结

位运算在算法题中的应用主要集中在：
- 状态压缩（子集、排列组合问题）
- 快速计算（乘除2的幂次）
- 数字性质判断（奇偶性、2的幂等）
- 空间优化（用整数表示多种状态）
- 负数处理（符号判断、无分支计算）

**关键掌握点：**
- 理解补码表示原理和负数位运算行为
- 熟练运用 `n & (-n)` 获取最低位1的技巧
- 注意位运算优先级和跨语言差异
- 避免负数位运算的常见陷阱

掌握这些核心概念和技巧，能够在面试中展现对底层原理的理解和优化意识。